# 347. Top K Frequent Elements

## 題目連結
[LeetCode](https://leetcode.com/problems/top-k-frequent-elements)

## 題目簡述
給定一個整數數組，請找出其中出現頻率前k高的元素。

範例：
- 輸入: nums = [1,1,1,2,2,3], k = 2
- 輸出: [1,2]
原因：1出現3次，2出現2次，3出現1次，前兩個頻率最高的元素是1和2。

## 解法
遍歷陣列把所有的值都存到map裡面去計算出現次數，然後創建一個物件的陣列包含值和出現次數，接著對這個陣列進行排序，最後取出前k個元素的值。

## 時間 / 空間複雜度
- 時間：O(n + m log m)，其中 n 是陣列的長度，m 是pairs陣列的長度（不同元素的數量）
- 空間：O(N)，需要額外的空間來存儲頻率（儲存 freqMap 與 pairs）

## 心得
看很多人是用bucket sort或是min-heap的方式來排序，但我覺得這樣蠻複雜的xd，直接用內建的sort應該會比較快。
後來看一下bucket sort的解法，時間複雜度是O(N)，空間複雜度也是O(N)，應該是最快的解法了，其實也覺得蠻聰明的，直接把出現次數當作bucket的index，然後把值放進去，所以從後面開始取值就可以撈到前k個頻率最高的元素。

來，直接用你這筆資料 Bucket Sort 乾跑一遍：
nums = [1,2,1,2,1,2,3,1,3,2], k = 2，n = 10

**Step 1: 計數（freqMap）**

掃過一次：

1 → 4 次

2 → 4 次

3 → 2 次
freqMap = {1:4, 2:4, 3:2}

**Step 2: 建桶（bucket）**

建一個長度 n+1 = 11 的切片，bucket[i] 放出現 i 次的數字。

把元素丟進對應桶：

出現 4 次的：[1,2] → bucket[4] = [1,2]

出現 2 次的：[3] → bucket[2] = [3]
其餘桶為空。

此時：
```
bucket[0] = []
bucket[1] = []
bucket[2] = [3]
bucket[3] = []
bucket[4] = [1,2]
bucket[5..10] = []
```
**Step 3: 從高頻往低掃，收集到 k 個**

從 i = 10 → 0 掃：

i=10..5：都空

i=4：看到 bucket[4] = [1,2]
這一桶就已經有 兩個元素，而且兩個的頻率一樣高（都是 4）。
